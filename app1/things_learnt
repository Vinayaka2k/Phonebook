1. React - Components, props, 
2. Basics of web apps, Network Tab in browser, SPA
3. Javascript - The value of this is defined based on how the method is called
            - Normally, this refers to the global object; but to bind it to a obj, use : function.bind(obj)
4. Destructure values from object - Javascript
5. render -> used to re-render the component -> component.render()
6. Event handlers, onClick
7. Calling a function which changes the state causes the component to rerender.
8. The state always has to be proporagted upwards from current component to the closest ancestor.
    - the parent component should defined the states and has to pass it though props to the child components
9. Never mutate the state directly. For all fields values are not changed, copy those from previous state. For
those which need to be changed, change the fields in the copied version of the previous state
10. Use concat over push when the state is an array. In concat, a copy of the state is returned and we dont modify the state directly
11. Conditional rendering -> returns inside components are based on the different values of states
12. The hooks - useState or useEffect may only be called inside a function defining a component. That is, they cant be called inside a loop, or conditional statement or a function inside the component. This is to ensure that the hooks are called in the same order
13. Event handlers must always be assigned to return values of functions. The below code is flawed since setValue(0) returns nothing. And the correct way was to set the value inside of a function and refer the function in event handler.
Also, the below code runs infinintely since when the component is rendered, setValue(0) is executed even though the button is not clicked and component re-renders 
<button onClick={setValue(0)}>click me</button>

14. Dont define components inside other components
15. JSX is more similar to javascript than to html. Although it looks like JSx is simimlar to HTML, it is compiled to JS
automatically by Babel
16. Notes App
17. Key attributes are mandatory when rendering a collection dynamically using map since React uses these key attributes 
to know how to update the view generated by the component when the component is re-rendered
18. Use indexes as key for rendering a collection only when either data is static or you're not filtering or sorting list items. Because, when index is used as key and when new items are added or exisiting items are reordered, then index of all other items changes and since the keys of items are different, all list items are re-ordered
19. Forms
20. Controlled elements -> an input element can be conttrolled by a component. Ex - in a form to add new notes to the notes list, we have an input element and the onChange handler must be set so that on any change of input element, handler is triggered and the handler sets the state to the new value.
Basically, the value of input element is controlled by the component
21. In script of package json, we can defined custom scripts that can be used with npm
22. json-server is just used to server a json that can be consumed by frontend. Main use is while development, before setting up an actual server, we can use json-server to mock the json and test the frontend
23. npm i <package> --save-dev : used to save the package as dev dependecncy. If we dont specify this, by default it would be saved as runtime depenedency
24. TO make react in browser notice the changes immediately without reloading the tab, create a .env file and add: FAST_REFRESH=false
25. axios.get("URL").then(response => { ... })
26. Functional components vs class components
27. Effect hook lets you to perform side effects on components. Setting up a DB connection, Data fetching, etc
28. useEffect is triggered immediately after the component renders for the first time
29. useEffect(Function, how frequently effect must be run) -> If 2nd parameter is [], implies that effect must be run once after the component is re-rendered
30. React Dev Env
The react_dev_server launches as soon as npm start is executed and it fetches the .js file and gives it to the browser. The browser renders the file and also fetches db.json from the json-server.
31. Dont use await/async directly in useEffect as effect functions are syncronpus to prevent race conditions. Instaed define a new method inside and call async/await inside that
32. Define env vars in a file called .env and access it using process.env.ENV_VAR
33. REST
Refer to indivaidual data objects as resources
Every resource has a unique address/URL -> baseUrl/resourceType/resourceId
To get a list of all resouces for a particular resource type -> baseUrl/resouceType
34. We can also mock POST request to JSON-Server and a new resource would be added to db.json 
35. POST vs PUT : PUT is idempotent. No matter how many times you PUT, it always replaces the resource with an updated version. Where as POST is not idmpotent and is used to change the existing resource. 
36. In db.json, id of values are auto generated automatically by jsonserver
37. For applying CSS, link an external stylesheet using import .css
Use className instead of class to specify the class names


BACKEND - NODE
1. create new app using npm init -> creates a package.json
2. create index.js 
3. to run -> node index.js
4. You can also add script as -> node index.js and make it point to "start" so that we can just run "npm start"
5. We can create a basic wen server using http.createServer and build out the response from scratch using writeHead and end. And bind the entire app to listen to a port so that when we go to localhost:PORT, we would be able to hit server
6. Node is nothing more than a index.js and package.json file. Along with few other .js helper files

CommonJS vs ES6 modules
1. require() for import "vs" import {Functions} from "./file"
2. module.exports = {moduleName: exportedModuleName} "vs" export function foo OR export default function
3. Used in NodeJS "vs" Used in Javascript
4. ES6 is the modules used in JS by default whereas CommonJS was developed for NODE even before ES6 was created

EXPRESS
1. Since creating server using http module requires lot of code, express provides an abstarction where we need to build a backend server
2. In dependencies, major.minor.patch and all releases have to be backward compatible -> meaning if we have any next versions with the same major version as current version, IT HAS TO run current version without any issues
3. Create new app using -> app = express()
Register routes using -> app.get('/:paramName', (req, res) => {res.json(...)})
Bind the app to port using -> app.listen(PORT, () => {...})
4. Remember that JSON is a string and not a dictionary
5. Note that the params inside ROUTE can be extracted using request.params.paramName
6. Note that the POST data can be accessed as such : req.body
7. Always use express json-parser while doing a POST -> app.use(express.json())
Without the json-parser, the body property of req would be undefined. The json-parser basically takes the json data of a request and transforms it into a JS object and then attaches it to the body property of request
8. List of Methods that can be used on response Object like : response.method()
res.json()
res.status()
res.send()
res.end()

NODEMON
1. Nodemon watches the files for change in the directory and auto restarts the server on change of any files

HTTP VERBS
1. GET, HEAD
Must always be safe -> it must not cause any side effects other than retriveal of data
Note that HEAD returns only status code + response headers. ResponseBody wont be returned

2. POST
All methods except POST are idempotent -> No matter how many times you make the request, the end result is the same as that of making a single request
Ex. for DELETE, if you make request 1 time or N times, the result is the same. The record no longer exists in the server. Note that we dont care about the status code. We only care about the state of the server in idempotence


MIDDLEWARES
1. Defined using : 
const function = (request, response, next) => {
    ...
    next()
}
2. At the end of the body, the next function that was passed as parameter is called
3. Middlewares are used as such : app.use(function)
4. MWs are called the order in which they are taken into use
5. MWs can be taken into use before/after routes. 
6. A MW can be defined after all routes to handle the case of no route matching the request 

REST HTTP VERBS
POST -> creates a new resource -> http://url/resourceType
PUT -> replaces the resource with a new one -> http://url/resourceType/resourceId
DELETE -> delets the resource -> http://url/resourceType/resourceId
PATCH -> replaces a part of the resource with the request data -> http://url/resourceType/resourceId


CORS
Cross origin resource sharing allows only the resources with the same origin (URL+PORT) to be shared among each other by default. To share resources with other origins as well, use the cors middleware from express


DEPLOY TO INTERNET
1. DEPLOY BACKEND
- Use fly/render/heroku
- First authencate in local and create a new app in local
- specify how to launch your app -> node index.js
- Finally deploy your app to get a URL on which the app is deployed
- basically these services deploy your app in nodejs env and generate a global URL and serve requests/responses
- Use log commands to get logs of whats happening in your server
- process.env.PORT
- Can set up auto deploy -> once pushed to git, auto deploy to render
- https://phonebook-svf2.onrender.com/


2. DEPLOY FRONTEND
- Use npm run build and copy the build folder to the backend root
- The build folder contains a single html index file and all other files are minified

3. SERVE STATIC FILES FROM THE BACKEND
- After the frontend's build is copied to the backend folder, we need to server frontend's static files when the server is hit
- So, we use -> app.use(express.static('build')) middleware -> Whenever express gets a GET request, it checks if build directory contains the corresponding endpoint. If so, it returns it. Else, it searches for the endpoint in the backend routes
- Therefore, both the frontend and backend URLs are at the same address

4. DEPLOY ENTIRE APP TO INTERNET
- Add scripts to server to generate and copy build folder from frontend to backend. And script to deploy the backend
- npm config set script-shell "C:\Users\vinayaka.h\AppData\Local\Programs\Git\bin\bash.exe" -> to execute bash cmds in windows
- scripts -> "build:ui": "rm -rf build && cd ./app1/ && npm run build && cp -r build ../build"
- scripts -> "deploy": "npm run build:ui && node index.js"
- Finally -> npm run deploy

DATABASES
MONGO - Document DB - NoSQL DB

- SetUp MONGODB
1. create a new cluster
2. add username and password (Vinayaka, vinayaka2000)
3. Mongoose is a ODM(object document mapper) -> maps JS objects to Mongo documents
4. mongodb+srv://Vinayaka:vinayaka2000@cluster0.goed3nq.mongodb.net/mydb?retryWrites=true&w=majority
5. mydb is the name of the database and collection Persons is created under that
6. npm i mongoose

MONGOOSE SCHEMA
- schema tells us how the objects are stored in the db
- const mySchema = new mongoose.Schema({
    colName: dataType
})

Mongoose Model
- const Model = mongoose.model('Name', mySchema)
- Mongoose names the model as 'names'
- Mongo is a schemaless DB -> the db doesnt care aboyt the structure of data stored -> its possible to store documents with completetly different fields in the same collection
- Then what is the use of schema ? Basically, schema is defined on the level of the application that defines the shape of the documents stored in any collection
- Models are constructor functions that create new objects. These objects have access to functions to save objects since they are created from Model Class

Creating/Saving objects
- Const newObj = new ModelName({
    colNames: values
})
- await newObj.save()
- mongoose.connection.close()

Fetching objects
- newObj.find({colName: value})

Transform objects
- Every object created by a mongoose schema has _id and __v. We can convert the _id to string and delete __v using toJSON method
- If we define a transform toJSON method on personSchema, the toJSON method is called whenever JSON.stringify or res.json() is called

- dotenv
Create a new .env file at the root to store mongoURI and port. Use dotenv module to populate the contents from .env file to make it available in process.env variable so that it can be used in the code

ERROR HANDLING
- We can define a MW for error handling. Express Error handlers are MW that accept 4 params. If any of the condition match, the error handler sends the response ELSE the MW passes the error forward to the default express error handler
- const errorHandler = (err,req,res,next) => {
    if(err.name == '...')
        return res.status(400).json(...)
    next(err)
}
- In any route -> app.HTTP_VERB(req,res,next) => {
    something
    .then()
    .catch(error => next(error))
}
- The error parameter is passed inside the next function so that the execution can go to the error handler MW.
But, if next was called without a parameter, the execution would move to the next route or middleware
- NOTE: In any MW, if we use next() -> the control goes to the next MW/routeHandler. If we dont use next, it skips over the remaining Mw/routerhandlers and exits
- The order of MW loading is the same as the order in which they are taken into use. Also, note that the error handling MW has to be the last MW that is loaded

VALIDATION IN MONGOOSE
- Its possible to set up validation rules like required, minLength while creating a new schema so that mongo would throw an error in the route handler if we try to violate the schema. And this error can be easily caught with the help of error handling MW
- On updateOperation, validators are off by default. You have to turn them on

Routers
- A router object is like a mini application capable of performing only middleware and routings
- Every express app has a built-in app router
- Routers must only define the relative paths of routes. You can define the initial part of the URL to be matched in the app.js file
